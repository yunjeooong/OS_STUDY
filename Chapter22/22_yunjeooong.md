# 22장 물리 메모리 크기의 극복: 정책 (Policy Deep Dive)

운영체제의 가상 메모리(VM) 시스템에서 **페이지 교체 정책**은 메모리가 부족할 때 어떤 페이지를 디스크로 내보낼지 결정하는 핵심 메커니즘입니다. 
디스크 I/O가 메모리 접근보다 수천 배 느리므로, 미스율을 최소화하는 것이 전체 성능(AMAT)을 좌우합니다.

---

## 1. 캐시와 VM: 성능 모델링

- 메인 메모리는 디스크 뒤에 있는 "큰, 느린" 저장 계층의 앞단 캐시로 동작
- **AMAT**(Average Memory Access Time):
  \[
  \mathrm{AMAT} = P_{hit} \times T_M + P_{miss} \times T_D
  \]
    - $T_M$: 메모리 접근 지연 (예: 100 ns)
    - $T_D$: 디스크 접근 지연 (예: 10 μs)
    - $P_{hit}$, $P_{miss}$: 히트/미스 확률 (합=1)

> 디스크 접근이 비쌀수록 작은 미스율 차이도 AMAT에 큰 영향을 줍니다.

---

## 2. 최적 교체 정책 (Optimal)

- Belady의 OPT(MIN) 정책: **미래 참조**를 알고 있다고 가정, "가장 오랫동안 다시 참조되지 않을" 페이지를 evict
- **장점**: 미스율 최소화
- **단점**: 미래를 알 수 없어 구현 불가능 → 비교 기준으로만 사용

---

## 3. 간단한 정책

### 3.1 FIFO (First-In–First-Out)
- 큐에 진입 순으로 삽입, 교체 시 가장 오래된 페이지를 evict
- 장점: 구현 단순 / 단점: Belady’s Anomaly 발생 가능

### 3.2 Random
- 교체 대상을 무작위 선택
- 장점: 극단적 단순 / 단점: 운에 따라 성능 편차 큼

---

## 4. 과거 정보 기반 정책

**지역성(locality)** 원칙에 기반, "최근성(recency)" 또는 "빈도수(frequency)"를 활용합니다.

### 4.1 LRU (Least-Recently-Used)
- "가장 오래 전에 참조된" 페이지를 evict
- 장점: 시간 지역성을 잘 반영 → 많은 워크로드에서 OPT 근접
- 단점: 완전 구현 시 오버헤드 큼

### 4.2 LFU (Least-Frequently-Used)
- "가장 적게 참조된" 페이지를 evict
- 장점: 자주 사용되는 페이지 보호 / 단점: 과거 편향 발생

---

## 5. 워크로드별 성능 비교

1. **지역성 전무**: 모든 정책 히트율 동일
2. **80:20 워크로드**: 최적 ≫ LRU > FIFO≈Random
3. **순차 반복**: LRU/FIFO 히트율 0%, Random 일부 히트

---

## 6. LRU 근사 (Approximation)

### 6.1 시계 알고리즘 (Clock)
- 페이지를 환형 리스트로 관리, use bit 검사→0이 될 때까지 순환

### 6.2 변형된 시계
- 랜덤 순서 검사, use bit=1→비트←0 후 다음, use bit=0인 페이지 evict
- 탐색 내성(scan resistance) 추가 → 순차 워크로드 방어

---

## 7. 더티 페이지 고려

- **Dirty bit** 하드웨어 지원: 수정된 페이지는 디스크 쓰기 비용 가중
- 정책 확장: Dirty=0인 "깨끗한" 페이지 우선 evict

---

## 8. 기타 VM 정책

- **Demand paging** vs. **Prefetching**
- **클러스터링/쓰기 모으기**: Dirty 페이지를 모아 한 번에 큰 I/O

---

## 9. 쓰래싱(Thrashing)과 해법

- 워킹 셋 초과 시 끊임없는 페이징 → 시스템 정체
- **해법**: 워킹 셋 기반 입장 제어, OOM 킬러, 일부 프로세스 중지 등

---

## 10. 결론

1. OPT 정책은 이론적으로는 완벽하지만 현실적으로는 쓸 수 없는 이상적인 기준, 실제 구현은 불가 → 비교 기준
2. FIFO/Random vs. LRU/LFU → 워크로드별 절충
3. Clock/ARC 등의 LRU 근사로 현실적 구현
4. 워크로드·하드웨어 특성에 맞춰 정책 선택
5. 궁극 해법: 더 많은 메모리 구매로 페이징 횟수 자체 감소

