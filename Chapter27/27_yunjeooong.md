

# Chapter 27 — POSIX 스레드 API 

---

## 1. 스레드 API가 필요한 이유
| 질문 | 답변 — **왜 그런가?** |
|------|-----------------------|
| **새 스레드를 어떻게 만들까?** | 하나의 프로세스 안에 **독립 실행 흐름**을 늘려 I/O 대기를 숨기고 멀티코어를 활용하기 위해서. |
| **언제 종료를 기다려야 할까?** | 결과를 수집하거나 다음 단계로 넘어가기 전에 **모든 작업이 끝났음을 보장**해야 하는 병렬 계산·배치 작업에서. |
| **공유 데이터는 왜 락을 걸어야 하나?** | CPU / 코어 / 인터럽트 타이밍에 따라 발생하는 **레이스 컨디션**을 방지해 논리적 일관성을 확보하기 위해. |
| **busy‑wait 대신 조건변수가 필요한가?** | 플래그 폴링은 CPU 사이클을 태우고 미묘한 버그(파이프라인 재정렬, 캐시 불일치)를 초래하므로, **수면‑신호 모델**이 안전·효율적. |

---

## 2. `pthread_create()` — 스레드 **생성**

```c
#include <pthread.h>

int pthread_create(pthread_t      *thread,
                   const pthread_attr_t *attr,   /* 주로 NULL */
                   void *(*start_routine)(void*), /* 새 스레드의 main */
                   void *arg);                    /* 인자 */
```

| 파라미터 | 의미 & **왜 필요한가?** |
|-----------|-----------------------|
| `thread` | 커널이 할당한 TCB의 핸들을 돌려줌 → 이후 `join`·`detach` 때 필요 |
| `attr` | 스택 크기·우선순위 등을 **커스터마이즈**. 대부분 기본값이면 `NULL`. |
| `start_routine` | 스레드가 진입할 함수 포인터. C에서 “함수를 값으로 전달”하는 유일한 수단. |
| `arg` | `void*` 만능 포인터 → 모든 자료형을 담을 수 있어 API가 **타입 독립적**. |

> ### 💡 실전 Tip  
> *여러 인자를 넘겨야 할 때* 구조체에 싸서 전달하고 **힙(또는 정적)** 에서 할당해라.  
> 스택에 만든 객체 주소를 넘기면 부모 스레드가 리턴한 뒤 **UAF(Use‑After‑Free)** 로 이어진다.

---

## 3. `pthread_join()` — 스레드 **완료 대기**

```c
int pthread_join(pthread_t thread, void **retval);
```

* **왜?** 스레드가 끝나야만 얻을 수 있는 값(예: 계산 결과)이 있을 때 필수.  
* `retval` 에는 `start_routine()` 의 반환 포인터가 저장된다.  
  *반드시* 힙 주소 혹은 `NULL` 을 반환. 스택 주소를 돌려주면 스레드 종료 시 소멸되어 **미정의 동작**!

> #### 언제 `join` 하지 않는가?  
> 지속 서비스용 워커(웹서버 I/O 스레드 등)는 **분리(detach)** 하여 스스로 자원을 회수하게 만든다.

---

## 4. `pthread_mutex_*` — **락**으로 상호배제

### 4‑1. 초기화

```c
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;   /* 정적 */
pthread_mutex_init(&lock, NULL);                    /* 동적 */
```
초기화를 빼먹으면 `lock/unlock` 이 `EINVAL` 로 실패 → **락이 풀리지 않아 데드락**.

### 4‑2. 기본 연산

```c
pthread_mutex_lock(&lock);   /* 블로킹, 스핀 ↔ 슬립은 구현체가 선택 */
critical_section();
pthread_mutex_unlock(&lock);
```

*Wrapper* 로 리턴 코드를 assert 체크(관례상 `Pthread_mutex_lock`) → 오류를 조기에 포착.

### 4‑3. 변형

| API | 용도 | 주의 |
|-----|------|------|
| `pthread_mutex_trylock` | 락이 이미 점유 중이면 즉시 `EBUSY` 반환 | 오류 흐름이 많아져 흔히 **지양** |
| `pthread_mutex_timedlock` | 절대 시간까지 대기 | 타임아웃 계산·시계 변경 이슈 |

---

## 5. `pthread_cond_*` — **조건변수**로 사건 동기화

```c
pthread_cond_wait(&cond, &lock);   /* 잠들며 lock을 원자적으로 놓음 */
pthread_cond_signal(&cond);        /* 슬립 중 1개 깨움 */
```

### 5‑1. 핵심 규칙 (**왜 지켜야 하나?**)
1. **반드시 같은 mutex를 보유한 상태**에서 `wait/signal` 호출  
   → 시그널 전/후의 공유 상태를 **일관**되게 관찰.
2. `wait()` 은 깨기 직전에 mutex를 다시 획득한 뒤 리턴  
   → 깨어난 쓰레드가 바로 상태를 검사할 수 있도록.
3. **`while (condition_not_met)`** 패턴  
   → 스퍼리어스 웨이크업 / 방송(broadcast) 혼선에 대비.

### 5‑2. 잘못된 플래그‑폴링 예

```c
/* CPU를 태우고 메모리 일관성 보장도 안 됨 — 사용 금지! */
while (ready == 0) ;
```

> 연구 결과[Xiao et al., 2010]에 따르면 플래그 기반 동기화의 **50 % 이상이 버그**를 유발.  
> 조건변수가 번거로워도 *반드시* 사용하자.

---

## 6. 컴파일 & 링크

```bash
gcc -Wall -pthread -o app main.c
```
`-pthread` 플래그가 헤더 정의 + 링커 옵션(`-lpthread`)을 동시에 추가한다.

---

## 7. 자주 만나는 **실수 체크리스트**

| 실수 | 결과 | 예방법 |
|------|------|---------|
| 스레드에 스택 자료 주소 반환 | UAF → 세그폴트 | 구조체를 `malloc()` 후 반환 |
| `pthread_create` 직후 바로 `pthread_join` | 병렬 이득 0, 함수 호출과 동일 | **N > 1** 스레드 생성 후 한꺼번에 join |
| mutex 초기화 안 함 | `EINVAL` → 데드락 | `PTHREAD_MUTEX_INITIALIZER` or `pthread_mutex_init` |
| `cond_wait` 에 `if` 사용 | 데이터 미변경인데도 진행 → 레이스 | **`while` 루프** 사용 |

---

## 8. 호출 흐름 

1.	pthread_create() 호출
메인 스레드가 새 스레드를 만들면서 함수 포인터(start_routine)와 인자(void* arg)를 넘깁니다. 
2. 커널은 TCB를 할당해 새 실행 흐름을 준비해 두고, 반환된 pthread_t 핸들로 나중 관리를 할 수 있게 합니다.
2.	새 스레드 진입 → start_routine() 실행
생성이 완료되면 스케줄러가 새 스레드를 CPU에 올리고, 전달받은 인자를 받아 start_routine() 함수가 실행을 시작합니다.
3.	공유 데이터 접근 여부 결정
start_routine() 안에서 먼저 전역/힙 같은 공유 자원에 접근해야 하는지 판단합니다.
•	공유 자원이 있다면 → 다음 단계로 락을 획득합니다.
•	없으면 → 바로 임계영역 밖의 로직을 수행합니다.
4.	pthread_mutex_lock() 으로 상호배제 확보
공유 자원에 접근해야 하는 경우, 먼저 해당 뮤텍스를 잠급니다.
•	이미 다른 스레드가 보유 중이면 스케줄러에게 양보하고 잠시 블로킹(또는 스핀)합니다.
•	락을 얻으면 임계영역에 진입할 권한을 확보합니다.
5.	임계영역(critical section) 실행
보호된 공유 데이터를 읽거나 수정합니다. 락을 잡고 있는 동안은 다른 스레드가 동일 데이터를 건드릴 수 없습니다.
6.	pthread_mutex_unlock() 으로 락 해제
임계영역이 끝나면 즉시 락을 풀어 다른 스레드가 자원에 접근할 수 있도록 합니다.
‼️ 락을 오래 잡거나 해제하지 않으면 데드락·성능 저하의 원인이 됩니다.
7.	작업 완료 후 pthread_exit() 호출(선택)
스레드가 맡은 일을 마치면 명시적으로 pthread_exit() 를 호출해 종료할 수 있습니다.
•	반환할 데이터가 있으면 힙에 저장한 포인터를 인자로 넘깁니다.
•	start_routine() 에서 return 을 사용해도 동일하게 종료됩니다.
8.	메인(혹은 다른) 스레드가 pthread_join() 으로 대기
스레드를 합류(join) 시키고 싶을 때, 생성 당시 받아 둔 pthread_t 핸들을 넘겨 pthread_join() 을 호출합니다.
•	대상 스레드가 아직 실행 중이면 블로킹되어 기다립니다.
•	스레드가 이미 끝난 상태라면 즉시 반환하며, 두 번째 인자(void**)에 종료 값이 전달됩니다.
9.	필요 시 결과 사용 후 메모리 해제
join 으로 받은 포인터가 힙 영역이라면, 결과를 처리한 뒤 반드시 free() 해 줍니다. 그래야 메모리 누수가 없습니다.

요약
create → (필요 시) lock → critical section → unlock → exit → join
 : 이 순서를 지키면 스레드 간 데이터 충돌 없이 안전하게 병렬 작업을 수행할 수 있습니다.

---

## 9. 요약 키워드

> **“락으로 원자성, 조인으로 완료 보장, 컨디션으로 순서 제어.”**  
> 이 세 프리미티브가 스레드 안전 프로그램의 80 %를 책임진다. 나머지 20 %는 **올바른 초기화와 반환 값 검증**이다.

---