

# Chapter 28

---

## 1. 왜 락이 필요한가?

- **원자성 부여**: 한 스레드가 임계 영역(공유 데이터 갱신)을 실행하는 동안 **다른 스레드의 개입을 차단**해 “하나의 거대한 명령어”처럼 보이게 한다.  
- **데이터 무결성**: 레이스 컨디션을 제거해 순서에 따라 달라지는 비결정적 버그를 예방한다.  
- **개발자 제어권 회수**: 스케줄러가 마음대로 문맥교환해도, 락으로 둘러싼 코드 내부는 우리가 결정한 순서대로 실행된다.

---

## 2. 락의 기본 모델

| 상태 | 설명 |
|------|------|
| **Unlocked / Free** | 아무도 락을 소유하지 않음 → 즉시 획득 가능 |
| **Locked / Held**   | 정확히 한 스레드가 소유 → 다른 스레드는 대기 |

```c
lock_t m;
lock(&m);        // 락 획득 (block or spin)
critical_section();
unlock(&m);      // 락 해제
```

> **Why?** 임계 영역을 `lock()/unlock()` 쌍으로 감싸면 “하나만 들어간다”는 불변식이 보장된다.

---

## 3. 정확한 락의 3대 조건

1. **상호배제(Mutual Exclusion)**  
   → 동시에 둘 이상이 임계 영역에 들어갈 수 없어야 한다.  

2. **진행(Progress)**  
   → 임계 영역 밖에서 멈춘 스레드는 **다른 스레드의 진입**을 방해하지 않아야 한다.  

3. **한정 대기(Bounded Waiting / Fairness)**  
   → 어떤 스레드도 **무한히** 기다리지 않음을 보장해야 한다. (기아 방지)

---

## 4. 하드웨어 원자 연산과 스핀 락

| 명령 | 개념 & 왜 필요한가? | 간단 구현 스케치 |
|------|--------------------|------------------|
| **Test‑And‑Set (TAS)** | flag를 *읽고* 1로 설정을 **한 사이클**에 수행 → 다중 CPU에서도 찰나의 빈틈 없음 | `while (TAS(&flag)==1) ;` |
| **Compare‑And‑Swap (CAS)** | 예상 값과 실제 값을 비교해 같으면 새 값으로 교체 → wait‑free 자료구조에 활용 | `while (CAS(&flag,0,1)==1) ;` |
| **Load‑Linked / Store‑Conditional (LL/SC)** | 읽은 이후 누가 건드렸는지 **모니터**하다가 건드리지 않은 경우에만 저장 성공 | `do { old=LL(x); } while(!SC(x,old+1));` |

### 스핀 락 vs 블로킹 락
- **스핀**: 짧은 임계 영역 + 멀티코어 환경에서 유리, 커널 공간 코드에서 주로 사용.  
- **블로킹(mutex)**: 긴 임계 영역이나 단일 CPU에서 효율. 커널이 `sleep → wake‑up` 해 스케줄러 낭비↓.

---

## 5. POSIX Mutex 빠른 정리

```c
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&m);   /* 필요 시 슬립 */
...   /* 공유 데이터 갱신 */
pthread_mutex_unlock(&m);
```

- **속성(attr)** 로 재귀 락, 우선순위 상속, 오류체크 등 세밀하게 설정 가능.  
- **pthread_mutex_trylock()** 으로 busy‑wait 없이 “즉시 실패” 검사 패턴 실현.

---

## 6. 공정성과 백오프(back‑off)

- **티켓 락(ticket lock)**: 번호표 기반 FIFO → 기아 방지, 단일 메모리 변수를 사용해 캐시 슬래시 감소.  
- **MCS/CLH 큐락**: CPU 당 노드 하나씩 연결해 원격 캐시‑슬래시 폭발 억제.  
- **지수 백오프(spin then pause)**: 충돌 빈도에 비례해 CPU 낭비를 줄이고 캐시 병목 완화.

> **왜?** 단순 TAS 스핀락은 충돌 상황에서 bus lock 폭풍을 일으켜 성능이 급락한다.

---

## 7. 성능 고려 포인트

1. **임계 영역 길이**: 작게 유지 → 락 보유 시간↓  
2. **락 범위**: coarse‑grained ↔ fine‑grained — 세밀 락이 병렬성↑, 그러나 데드락 위험 ↑.  
3. **컨텐션 패턴**: 읽기 다중·쓰기 희소 → RW‑Lock 고려.  
4. **CPU 수 vs 스레드 수**: 단일 CPU + 스핀락 = 최악; 멀티코어 + 짧은 CS = 효과적.

---

## 8. 락 사용 주의사항 & 대응 전략

| 오류 | 결과 | 예방책 |
|------|------|---------|
| 락 획득 후 `return`·`goto` 로 해제 누락 | 데드락 | `RAII` (스코프 락) 패턴 or `pthread_cleanup_push` |
| 블로킹락을 인터럽트 핸들러에서 사용 | 커널 패닉 | 스핀락/원자 연산만 사용 |
| 순환 락 획득 | 데드락 | **고정 순서** 규칙 or try‑lock + back‑off |
| 넓은 범위 coarse 락 | 병렬성↓ | 자료 구조별 세밀 락 분리 |

---

## 9. 요약 한 줄

> **“락은 원자성을 파는 도구다 — 올바른 원자 연산 + 짧은 임계 영역 + 공정성 설계가 성능과 안정성의 키.”**

---