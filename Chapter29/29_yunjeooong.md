

# Chapter 29 


---

## 1. 왜 ‘락 사용법’이 따로 필요한가?  
이전 장(락 프리미티브)은 **“올바른 상호배제”** 에 집중했다.  
하지만 실제 프로그램에 락을 끼워넣는 순간 성능·디버깅·코드 가독성이라는 **현실 문제**가 터져 나온다. 결국 개발자가 고민해야 할 질문은 세 가지다.

1. **정확성(Correctness)** – 데이터 일관성이 100 % 보장되는가?  
2. **확장성(Scalability)** – 쓰레드 수, CPU 수, 데이터 크기가 늘어도 선형 성능을 내는가?  
3. **단순성(Simplicity)** – 락 획득·해제 경로가 분명해 버그를 줄이는가?  
   > 모니터 패턴처럼 “함수 입구‑출구에서 자동 락”을 쓰면 실수를 크게 줄일 수 있다.

---

## 2. 락 디자인 5원칙 

| 원칙 | 설명 | 왜 중요한가? |
|------|------|--------------|
| **먼저 정확성** | 속도보다 ‘무결성’이 우선. 병행 버그는 재현이 어렵다. | 레이스는 결과가 비결정적이라 재현 비용이 치솟는다. |
| **임계영역 최소화** | 공유 데이터 부분만 짧게 감싸라. | 보유 시간이 짧을수록 충돌과 캐시 오염이 줄어든다. |
| **락 그레인 통제** | coarse (하나) ↔ fine (여러 개) 사이 균형 | 너무 세분화하면 데드락 그래프가 기하급수적으로 늘어난다. |
| **에러·리턴 경로 안전화** | malloc 실패, 예외 처리 시 **반드시 락 해제** | 락이 열린 채 함수 탈출 → 숨은 데드락. |
| **공정성·기아 방지** | FIFO, 티켓 락, 우선순위 상속 등 마련 | 무한 대기는 실제 서비스에서 SLA 파괴로 직결된다. |

---

## 3. 사례 1 — 카운터(counter)

### 3‑1. 단순 글로벌 락  
```c
typedef struct { int value; pthread_mutex_t lock; } counter_t;
void increment(counter_t *c){ pthread_mutex_lock(&c->lock); c->value++; pthread_mutex_unlock(&c->lock); }
```
*장점*: 구현 간단·정확.  
*단점*: 모든 쓰레드가 동일 락에 줄 서기 → 2 쓰레드부터 성능 붕괴. 실험 결과 4‑코어 i5에서 2개 쓰레드가 1M 증가 시 5 초 초과 소요.

### 3‑2. **Sloppy Counter(엉성한 카운터)**  
* 아이디어: **CPU 당 지역 카운터** + 전역 카운터.  
* 지역 값이 임계치 *S*를 넘으면 전역으로 플러시.  
* S ↑ → 정확도↓/성능↑, S ↓ → 정확도↑/성능↓.  
실험에서 *S = 1024* 설정 시 4 CPU 총 4 M 증가를 단일 쓰레드 시간과 거의 동일하게 달성했다.  
> **WHY?** 지역 락끼리 독립이라 충돌이 *NUMA 로컬*로 제한되고, 전역 락 충돌 빈도가 S에 반비례로 감소한다.

---

## 4. 사례 2 — 연결 리스트(list)

### 4‑1. 전역 락 버전  
`List_Insert()`·`List_Lookup()` 시작‑끝에 `pthread_mutex_lock()` / `unlock()`을 배치.
*문제*: `malloc()` 실패, 예외 리턴 등 **락 해제 누락** 위험 → 치명적 데드락.

### 4‑2. 수정: 락 밖 할당 + 공통 해제 경로  
1. 새 노드를 **락 없이** 할당.  
2. 락 획득 후 포인터 연결.  
3. 검색 루프에 `break` 추가해 성공/실패 모두 동일 exit 블록을 거침.     
> **WHY?** 락 경로를 단일화하면 코드 분지마다 unlock 호출을 잊을 가능성이 급감한다.

### 4‑3. Hand‑over‑Hand Locking(노드별 락)  
노드마다 락을 걸고 다음 노드 락을 먼저 잡은 뒤 현재 락을 푼다.  
*장점*: 중간 노드끼리 병행 탐색 가능.  
*단점*: **락 획득/해제 오버헤드**가 노드 수에 비례해 증가 → 작은 리스트에선 오히려 느리다. 

---

## 5. 사례 3 — Michael‑Scott Two‑Lock Queue

- **데이터 구조**: 더미 노드 1개 + `headLock`(deq 전용) / `tailLock`(enq 전용) 두 개.  
- **작동**: enqueue는 tail 락만, dequeue는 head 락만 사용 → 삽입·삭제가 거의 독립.  
- **효과**: 생산자/소비자 패턴에서 대기열 병목을 대폭 완화.  
> **WHY?** 큐가 비지 않을 땐 head·tail 영역이 메모리상으로 분리돼 캐시 슬래시도 최소화된다.

---

## 6. 사례 4 — 버킷 해시 테이블

- 해시 버킷마다 **개별 락** 부착.  
- 충돌 체인은 앞서 개선한 **연결 리스트(insert/lookup)** 로 구현.  
- 해시 함수가 균등 → 평균 **락 경합 = O(1/버킷수)**.  
> **WHY?** 해시가 균등하면 쓰레드가 서로 다른 버킷‑락을 잡을 확률이 높아져 병렬도가 선형 증가.

---

## 7. 성능 튜닝 체크포인트

1. **컨텐션 관측**: perf stat, `pthread_mutex_timedlock()` 실패율로 락 충돌 현황 측정.  
2. **백오프 삽입**: TAS 스핀락이라면 지수 백오프 / `sched_yield()` 로 버스 락 폭주 억제.  
3. **우선순위 역전 대응**: 리얼타임 스레드 포함 시 **Priority Inheritance** 속성 활성화.  
4. **NUMA Locality**: 지역 락·캐시 라인 패딩으로 false‑sharing 제거.

---

## 8.Thread‑Safe 코드 필수 확인

| 항목 | 설명 |
|------|------|
| **락 획득 후 모든 exit 경로에서 해제 확인** | `goto error:` 블록이 unlock을 포함하는지? |
| **스코프‑락(RAII) 사용** | C++ 스마트 락, 또는 `pthread_cleanup_push()`로 자동 해제 |
| **일관된 락 순서** | 다중 락 사용 시 A→B→C 순서를 글로벌 규칙화 |
| **무한 루프 안 스핀락 지양** | 단일 CPU 혹은 긴 CS는 블로킹 락으로 교체 |
| **성능 계측 포함** | 락 개선 전후 시간을 항상 측정 – “느림”을 추측하지 말 것 |

---

## 9. 한 줄 요약  
> **“락을 넣을 땐 ‘정확 → 단순 → 확장’ 순으로 설계하고, 사례별 패턴(카운터·리스트·큐·해시)을 재사용하라.”**  

---
