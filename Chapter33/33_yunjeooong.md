

# 33장: 이벤트 기반 병행성(고급)

이 장에서는 **이벤트 기반(event-based)** 스타일의 병행성 기법을 살펴본다.  
전통적인 멀티스레드 방식의 두 가지 문제(락·교착, 스케줄 제어 부족)를 완화한다.

---

## 33.1 기본 개념: 이벤트 루프

이벤트 기반 시스템은 다음 흐름으로 동작한다:
1. 이벤트 발생 대기
2. 이벤트 타입 파악
3. I/O 요청 또는 후속 이벤트 발생 처리

단일 루프 구조인 **이벤트 루프(event loop)** 가 모든 이벤트를 순차적으로 처리한다:

```c
while (1) {
    events = getEvents();
    for (e in events) {
        processEvent(e);
    }
}
```

---

## 33.2 주요 API: select() / poll()

- **select()**  
  - 디스크립터 집합 중 읽기/쓰기 가능 상태를 검사  
  - 준비된 디스크립터 수 반환  
  - 타임아웃 또는 즉시 리턴 설정 가능

- **poll()**  
  - select()와 유사한 기능

---

## 33.3 select() 사용 예시

```c
int main(void) {
    while (1) {
        fd_set readFDs;
        FD_ZERO(&readFDs);

        // 관심 있는 모든 FD 설정
        for (int fd = minFD; fd < maxFD; fd++) {
            FD_SET(fd, &readFDs);
        }

        // 이벤트 대기
        int rc = select(maxFD + 1, &readFDs, NULL, NULL, NULL);

        // 준비된 FD 처리
        for (int fd = minFD; fd < maxFD; fd++) {
            if (FD_ISSET(fd, &readFDs)) {
                processFD(fd);
            }
        }
    }
}
```

---

## 33.4 장점: 락 불필요

- 단일 스레드로 동작하므로 **락**(mutex) 획득·해제 과정이 필요 없다.

---

## 33.5 문제점: 블로킹 시스템 콜

- 이벤트 핸들러 내 블로킹 호출 시 전체 루프가 멈춰 자원 낭비 발생

---

## 33.6 해법: 비동기 I/O

- **폴링(poll)** 또는 **인터럽트/시그널** 기반으로 I/O 완료를 알림  
- 이벤트 루프가 중단 없이 다른 작업을 계속 수행

---

## 33.7 문제점: 상태 관리

- 비동기 콜 뒤의 연속적 작업을 위한 **수동 스택 관리** 필요  
- **continuation**(계속 정보) 개념으로 상태를 보존하고, 이벤트 발생 시 처리

---

## 33.8 추가 고려사항

- 멀티 CPU 환경에서 다중 이벤트 핸들러 병렬 실행 시 동기화 문제  
- OS 내부 블록(예: 페이지 폴트)와 조화 어려움  
- 비동기 디스크 I/O 지원 여부 다양성  

---

## 33.9 요약

- 이벤트 루프 기반으로 **락·교착** 문제 완화  
- **블로킹 호출**과 **상태 관리**가 주요 과제  
- **비동기 I/O**와 **continuation**으로 해결 방안 제공